---
hide_table_of_contents: false
---

# Task Management App – Developer Onboarding Guide

## Содержимое

1. [Обзор проекта](#Обзор-проекта)
2. [Стек](#Стек)
3. [Общая архитектура](#Общая-архитектура)
4. [Структура проекта](#Структура-проекта)
5. [Описание layers(слоёв)](<#Описание-layers(слоёв)>)
6. [Система маршрутизации](#Система-маршрутизации)
7. [UI архитектура](#UI-архитектура)

---

## Обзор проекта

### Current Status

Проект находится в активной разработке.

Планируется к разработке:

- Модуль привычек
- Pomodoro таймер
- Статистика и аналитика
- Сообщества
- Профиль пользователя

---

## Стек

### Основные технологии

**Frontend Framework:**

- React 18+ (с Hooks)
- TypeScript 5+
- Vite (build tool)

**Routing:**

- React Router v7

**State Management:**

- Zustand (для глобального состояния)
- React Hook Form (для форм)

**Validation:**

- Zod (схемы валидации и типизация)

**Styling:**

- Tailwind CSS v4
- tw-animate-css (анимации)
- Custom CSS variables (дизайн-токены)

**UI Components:**

- shadcn/ui (Radix UI + Tailwind)
- Lucide React (иконки)

**Development Tools:**

- ESLint (линтинг)
- Prettier (форматирование)
- TypeScript (статическая типизация)

---

## Общая архитектура

### Feature-Sliced Design (FSD)

Проект построен на архитектуре **Feature-Sliced Design** - методологии организации frontend-проектов

### Layer(Слоев) иерархия

```
┌─────────────────────────────────────┐
│             app                     │  ← Инициализация приложения
├─────────────────────────────────────┤
│            pages                    │  ← Композиция страниц
├─────────────────────────────────────┤
│           widgets                   │  ← Крупные блоки UI
├─────────────────────────────────────┤
│          features                   │  ← Бизнес-функции
├─────────────────────────────────────┤
│          entities                   │  ← Бизнес-сущности
├─────────────────────────────────────┤
│           shared                    │  ← Переиспользуемый код
└─────────────────────────────────────┘
```

**Правило импортов:**

```
app → pages → widgets → features → entities → shared
```

- Слой может импортировать **только из нижележащих слоёв**
- Запрещены импорты между модулями одного слоя
- Запрещены круговые зависимости
- Каждый модуль имеет явный Public API через `index.ts`

---

## Структура проекта

```
src/
├── app/                          # Слой инициализации приложения
│   ├── providers/                # Глобальные провайдеры
│   │   └── theme.tsx             # Провайдер темы
│   ├── routes/                   # Конфигурация роутинга
│   │   ├── config/
│   │   │   └── router.tsx        # Определение маршрутов
│   │   ├── ui/
│   │   │   └── AppRouter.tsx     # Роутер с Suspense
│   │   └── index.ts
│   ├── layout/                   # Общий layout
│   │   └── Layout.tsx            # Header + Outlet
│   ├── styles/                   # Глобальные стили
│   │   ├── fonts.css             # Подключение шрифтов
│   │   └── style.css             # Дизайн-токены, base стили
│   ├── App.tsx                   # Корневой компонент
│   └── main.tsx                  # Точка входа
│
├── pages/                        # Слой страниц
│   ├── dashboard/                # Главная страница
│   │   ├── ui/
│   │   │   └── DashboardPage.tsx
│   │   └── index.ts
│   ├── tasks/                    # Страница задач
│   │   ├── ui/
│   │   │   └── TasksPage.tsx
│   │   └── index.ts
│   ├── habits/                   # Страница привычек
│   │   ├── ui/
│   │   │   └── HabitsPage.tsx
│   │   └── index.ts
│   ├── pomodoro/                 # Страница помодоро
│   ├── communities/              # Страница сообществ
│   ├── statistics/               # Страница статистики
│   └── profile/                  # Страница профиля
│
├── widgets/                      # Слой виджетов
│   ├── header/                   # Шапка приложения
│   │   ├── ui/
│   │   │   └── Header.tsx
│   │   └── index.ts
│   ├── taskList/                 # Список задач
│   │   ├── ui/
│   │   │   └── TaskList.tsx
│   │   └── index.ts
│   └── taskDrawer/               # Drawer для задач
│       ├── ui/
│       │   └── TaskDrawer.tsx
│       └── index.ts
│
├── features/                     # Слой фич (пользовательские действия)
│   └── task/
│       ├── taskAdd/              # Добавление задачи
│       │   ├── ui/
│       │   │   ├── AddTaskButton.tsx
│       │   │   └── TaskForm.tsx
│       │   ├── model/
│       │   │   └── constants.ts  # Опции для форм
│       │   └── index.ts
│       ├── taskEdit/             # Редактирование задачи
│       │   ├── ui/
│       │   │   ├── OpenEditTaskDrawerButton.tsx
│       │   │   └── EditTaskForm.tsx
│       │   ├── model/
│       │   │   ├── schema.ts
│       │   │   └── utils.ts
│       │   └── index.ts
│       └── taskDelete/           # Удаление задачи
│           ├── ui/
│           │   └── DeleteTaskButton.tsx
│           ├── model/
│           │   └── useDeleteTask.ts
│           └── index.ts
│
├── entities/                     # Слой бизнес-сущностей
│   └── task/                     # Сущность "Задача"
│       ├── ui/                   # UI компоненты для отображения
│       │   ├── TaskCard.tsx      # Карточка задачи
│       │   └── TaskInfo.tsx      # Детальная информация
│       ├── model/                # Модель данных
│       │   ├── types.ts          # TypeScript типы
│       │   ├── schema.ts         # Zod схемы валидации
│       │   ├── mockData.ts       # Моковые данные
│       │   └── useTaskDrawerStore.ts  # Zustand store
│       ├── api/                  # API слой
│       │   └── tasksApi.ts       # Запросы к API
│       ├── lib/                  # Утилиты
│       │   └── mappers.ts        # DTO ↔ Model преобразования
│       └── index.ts              # Public API
│
└── shared/                       # Слой переиспользуемого кода
    ├── ui/                       # UI-kit компоненты
    │   ├── primitives/           # Radix UI обёртки
    │   │   ├── alert-dialog.tsx
    │   │   ├── calendar.tsx
    │   │   ├── dialog.tsx
    │   │   ├── drawer.tsx
    │   │   ├── dropdown-menu.tsx
    │   │   ├── popover.tsx
    │   │   ├── tabs.tsx
    │   │   └── index.ts
    │   ├── button.tsx            # Базовые компоненты
    │   ├── input.tsx
    │   ├── checkbox.tsx
    │   ├── textarea.tsx
    │   ├── formField.tsx
    │   ├── dataPicker.tsx
    │   ├── pageHeader.tsx
    │   └── ...
    ├── lib/                      # Утилиты
    │   ├── classnames/
    │   │   ├── cn.ts             # Утилита cn()
    │   │   └── index.ts
    │   └── drawerTaskManager/    # Generic drawer store
    │       ├── drawerStore.ts
    │       ├── types.ts
    │       └── index.ts
    ├── routes/                   # Константы маршрутов
    │   ├── routes.ts
    │   └── index.ts
    └── types/                    # Общие типы (если нужны)
```

---

## Описание layers(слоёв)

### Layer 1: app (Application Layer)

**Назначение:** Точка входа и глобальная конфигурация приложения.

**Содержит:**

- Инициализацию React-приложения (`main.tsx`)
- Композицию глобальных провайдеров (`App.tsx`)
- Конфигурацию роутинга (`routes/`)
- Общий layout с Header (`layout/`)
- Глобальные стили и дизайн-систему (`styles/`)

**Ключевые файлы:**

**`main.tsx`** - точка входа

```tsx
createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

**`App.tsx`** - композиция провайдеров

```tsx
function App() {
  return (
    <ThemeProvider>
      <AppRouter />
    </ThemeProvider>
  );
}
```

**`routes/config/router.tsx`** - определение маршрутов

```tsx
export const router = createBrowserRouter([
  {
    path: "/",
    Component: Layout,
    children: [
      { index: true, Component: DashboardPage },
      { path: ROUTES.tasks, Component: TasksPage },
      // ...
    ],
  },
]);
```

**`layout/Layout.tsx`** - общий layout

```tsx
export const Layout = () => (
  <div className="flex h-screen">
    <div className="flex flex-col flex-1 w-full">
      <Header />
      <main className="flex-1 bg-bg-secondary px-2 sm:p-3 md:p-4">
        <Outlet />
      </main>
    </div>
  </div>
);
```

**Правила:**

- НЕ содержит бизнес-логики
- Только композиция и конфигурация
- Не экспортируется в другие слои

---

### Layer 2: pages (Pages Layer)

**Назначение:** Композиция страниц из виджетов и фич.

**Содержит:**

- Компоненты страниц
- Минимальную логику получения данных
- Композицию виджетов и фич

**Структура страницы:**

```
pages/tasks/
├── ui/
│   └── TasksPage.tsx
└── index.ts          # export { TasksPage as default }
```

**Пример: TasksPage.tsx**

```tsx
import { PageHeader } from "@/shared/ui/pageHeader";
import { AddTaskAction } from "@/features/task/taskAdd";
import { fetchTasks } from "@/entities/task/api/tasksApi";
import { TaskDrawer } from "@/widgets/taskDrawer";
import { TaskList } from "@/widgets/taskList";

const tasks = fetchTasks();

export const TasksPage = () => {
  return (
    <div>
      <PageHeader title="Tasks" action={<AddTaskAction />} />
      <div className="flex flex-col">
        <TaskList tasks={tasks} />
      </div>
      <TaskDrawer />
    </div>
  );
};
```

**Анатомия страницы:**

1. `PageHeader` - заголовок с действием
2. `AddTaskAction` - feature для добавления задачи
3. `TaskList` - widget для отображения списка
4. `TaskDrawer` - widget для просмотра/редактирования

**Правила:**

- Только композиция виджетов и фич
- Минимальная логика (fetch данных)
- Default export через `index.ts` для lazy loading
- Не содержит сложной бизнес-логики

---

### Layer 3: widgets (Widgets Layer)

**Назначение:** Крупные самодостаточные блоки UI.

**Содержит:**

- Составные компоненты
- Композицию entities и shared компонентов
- Независимые секции интерфейса

**Структура widget:**

```
widgets/taskList/
├── ui/
│   └── TaskList.tsx
└── index.ts
```

**Пример: TaskList**

```tsx
import { TaskCard } from "@/entities/task/ui/TaskCard";
import { DeleteTaskButton } from "@/features/task/taskDelete";
import { OpenEditTaskDrawerButton } from "@/features/task/taskEdit";

export const TaskList = ({ tasks }: TaskListProps) => {
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {tasks.map((task) => (
        <TaskCard
          key={task.id}
          task={task}
          actions={
            <>
              <OpenEditTaskDrawerButton task={task} />
              <DeleteTaskButton taskId={task.id} />
            </>
          }
        />
      ))}
    </div>
  );
};
```

**Композиция:**

- `TaskCard` (entity) - карточка задачи
- `OpenEditTaskDrawerButton` (feature) - кнопка редактирования
- `DeleteTaskButton` (feature) - кнопка удаления

**Пример: TaskDrawer**

```tsx
import { Drawer, DrawerContent, DrawerHeader } from "@/shared/ui";
import { useTaskDrawerStore } from "@/entities/task";
import { TaskInfo } from "@/entities/task/ui/TaskInfo";
import { EditTaskForm } from "@/features/task/taskEdit/ui/EditTaskForm";

export const TaskDrawer = () => {
  const { isOpen, data, mode, closeDrawer } = useTaskDrawerStore();

  if (!data) return null;

  return (
    <Drawer open={isOpen} onOpenChange={closeDrawer}>
      <DrawerContent>
        <DrawerHeader>
          <h2>{data.title}</h2>
        </DrawerHeader>

        {mode === "view" ? <TaskInfo task={data} /> : <EditTaskForm />}
      </DrawerContent>
    </Drawer>
  );
};
```

**Правила:**

- Самодостаточные блоки UI
- Композиция entities и features
- Могут использовать shared компоненты
- Не содержат бизнес-логику операций

---

### Layer 4: features (Features Layer)

**Назначение:** Пользовательские действия и сценарии.

**Определение:** Feature = Завершённое действие пользователя, которое меняет состояние системы.

**Содержит:**

- UI для действий (кнопки, формы)
- Бизнес-логику операций
- Хуки с логикой
- Константы для фичи

**Структура feature:**

```
features/task/taskAdd/
├── ui/
│   ├── AddTaskButton.tsx    # Кнопка + модалка
│   └── TaskForm.tsx          # Форма создания
├── model/
│   └── constants.ts          # Опции для селектов
└── index.ts
```

**Примеры features:**

#### 1. taskAdd - Добавление задачи

**AddTaskButton.tsx:**

```tsx
import { useState } from "react";
import { Button } from "@/shared/ui/button";
import { BaseModal } from "@/shared/ui";
import { TaskForm } from "./TaskForm";

export const AddTaskAction = () => {
  const [open, setOpen] = useState(false);

  return (
    <>
      <Button onClick={() => setOpen(true)} size="sm">
        Add task
      </Button>
      <BaseModal open={open} onOpenChange={setOpen} title="Add New Task">
        <TaskForm />
      </BaseModal>
    </>
  );
};
```

**TaskForm.tsx:**

```tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { TaskFormSchema, type TaskFormTypes } from "@/entities/task";

export const TaskForm = () => {
  const form = useForm<TaskFormTypes>({
    resolver: zodResolver(TaskFormSchema),
  });

  const onSubmit = (data: TaskFormTypes) => {
    console.log("Creating task", data);
    // API call здесь
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <FormField label="Task title">
        <Input {...register("title")} />
      </FormField>

      <FormField label="Priority">
        <DropdownSelect
          name="priority"
          control={control}
          options={PRIORITY_OPTIONS}
        />
      </FormField>

      <Button type="submit">Create</Button>
    </form>
  );
};
```

#### 2. taskDelete - Удаление задачи

**DeleteTaskButton.tsx:**

```tsx
import { useState } from "react";
import { Trash2 } from "lucide-react";
import { Button } from "@/shared/ui/button";
import { ConfirmDialog } from "@/shared/ui";
import { useDeleteTask } from "../model/useDeleteTask";

export const DeleteTaskButton = ({ taskId }: { taskId: string }) => {
  const { isDeleting, handleDeleteTask } = useDeleteTask();
  const [showConfirm, setShowConfirm] = useState(false);

  return (
    <>
      <Button onClick={() => setShowConfirm(true)}>
        <Trash2 className="w-4 h-4" />
      </Button>

      <ConfirmDialog
        open={showConfirm}
        onOpenChange={setShowConfirm}
        onConfirm={() => handleDeleteTask(taskId)}
        title="Delete task?"
        description="This action cannot be undone."
      />
    </>
  );
};
```

**model/useDeleteTask.ts:**

```tsx
import { useTaskDrawerStore } from "@/entities/task";
import { useCallback, useState } from "react";

export const useDeleteTask = () => {
  const [isDeleting, setIsDeleting] = useState(false);
  const closeDrawer = useTaskDrawerStore((state) => state.closeDrawer);

  const handleDeleteTask = useCallback(
    async (taskId: string) => {
      try {
        setIsDeleting(true);
        // API call
        await api.deleteTask(taskId);
        closeDrawer();
      } catch (error) {
        console.error(error);
      } finally {
        setIsDeleting(false);
      }
    },
    [closeDrawer]
  );

  return { isDeleting, handleDeleteTask };
};
```

#### 3. taskEdit - Редактирование задачи

**OpenEditTaskDrawerButton.tsx:**

```tsx
import { Button } from "@/shared/ui/button";
import { Icon } from "@/shared/ui/Icon";
import { useTaskDrawerStore, type TaskCardType } from "@/entities/task";

export const OpenEditTaskDrawerButton = ({ task }: { task: TaskCardType }) => {
  const openDrawer = useTaskDrawerStore((state) => state.openDrawer);

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    openDrawer(task, "edit");
  };

  return (
    <Button onClick={handleClick}>
      <Icon name="pencil" />
    </Button>
  );
};
```

**EditTaskForm.tsx:**

```tsx
import { useForm } from "react-hook-form";
import { useTaskDrawerStore } from "@/entities/task";
import { TaskFormSchema, type TaskFormTypes } from "@/entities/task";

export const EditTaskForm = () => {
  const { data: task, closeDrawer } = useTaskDrawerStore();

  const form = useForm<TaskFormTypes>({
    resolver: zodResolver(TaskFormSchema),
    defaultValues: task,
  });

  const {
    formState: { isDirty },
  } = form;

  const onSubmit = (data: TaskFormTypes) => {
    // API call для обновления
    console.log("Updating task", data);
    closeDrawer();
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Поля формы */}
      <Button type="submit" disabled={!isDirty}>
        Save Changes
      </Button>
    </form>
  );
};
```

**Правила features:**

- Представляет законченное действие
- UI и логика разделены (компонент + хук)
- Использует типы из entities
- Не зависит от других features
- Public API через `index.ts`

---

### Layer 5: entities (Entities Layer)

**Назначение:** Бизнес-сущности приложения.

**Определение:** Entity = Объект предметной области со своим жизненным циклом.

**Содержит:**

- Типы и схемы данных
- UI для отображения сущности
- API методы (CRUD)
- Mappers (DTO ↔ Model)
- Stores для состояния

**Структура entity:**

```
entities/task/
├── ui/
│   ├── TaskCard.tsx          # Карточка задачи
│   └── TaskInfo.tsx          # Детальная информация
├── model/
│   ├── types.ts              # TypeScript типы
│   ├── schema.ts             # Zod схемы
│   ├── mockData.ts           # Моковые данные
│   └── useTaskDrawerStore.ts # Zustand store
├── api/
│   └── tasksApi.ts           # API запросы
├── lib/
│   └── mappers.ts            # Преобразования
└── index.ts                  # Public API
```

**model/types.ts:**

```tsx
import type { z } from "zod";
import { TaskFormSchema, TaskDtoSchema } from "./schema";

// Тип для форм
export type TaskFormTypes = z.infer<typeof TaskFormSchema>;

// Тип для API (DTO)
export type TaskDTO = z.infer<typeof TaskDtoSchema>;

// Тип для бизнес-логики (с Date объектами)
export type Task = Omit<TaskDTO, "dueDate" | "createdAt" | "completedAt"> & {
  dueDate?: Date;
  createdAt: Date;
  completedAt?: Date;
};

export type TaskCardType = Task;

export type Priority = "low" | "medium" | "high";
export type TaskStatus = "pending" | "in_progress" | "completed" | "cancelled";
```

**model/schema.ts:**

```tsx
import { z } from "zod";

// Схема для форм
export const TaskFormSchema = z.object({
  title: z.string().min(3, "Title must be at least 3 characters"),
  description: z.string().optional(),
  dueDate: z.date().optional(),
  category: z.string().optional(),
  priority: z.enum(["low", "medium", "high"]),
  pomodoro: z.number().optional(),
  status: z.enum(["pending", "in_progress", "completed", "cancelled"]),
});

// Схема для API (DTO)
export const TaskDtoSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().optional(),
  dueDate: z.string().optional(), // ISO строка
  category: z.string().optional(),
  priority: z.enum(["low", "medium", "high"]),
  pomodoro: z.number().optional(),
  status: z.enum(["pending", "in_progress", "completed", "cancelled"]),
  createdAt: z.string(), // ISO строка
  completedAt: z.string().optional(),
});
```

**model/useTaskDrawerStore.ts:**

```tsx
import type { TaskCardType } from "./types";
import { createDrawerStore } from "@/shared/lib/drawerTaskManager";

export const useTaskDrawerStore = createDrawerStore<TaskCardType>("taskDrawer");
```

**api/tasksApi.ts:**

```tsx
import { taskDtosToTasks } from "../lib/mappers";
import { mockTaskDtos } from "../model/mockData";

export const fetchTasks = () => {
  return taskDtosToTasks(mockTaskDtos);
};

// В будущем:
// export const createTask = async (data: TaskFormTypes) => {...}
// export const updateTask = async (id: string, data: Partial<TaskFormTypes>) => {...}
// export const deleteTask = async (id: string) => {...}
```

**lib/mappers.ts:**

```tsx
import type { Task, TaskDTO, TaskFormTypes } from "../model/types";

// DTO → Model (Date объекты)
export const taskDtoToTask = (dto: TaskDTO): Task => ({
  ...dto,
  dueDate: dto.dueDate ? new Date(dto.dueDate) : undefined,
  createdAt: new Date(dto.createdAt),
  completedAt: dto.completedAt ? new Date(dto.completedAt) : undefined,
});

// Model → DTO (ISO строки)
export const taskToTaskDto = (task: Partial<Task>): Partial<TaskDTO> => ({
  ...task,
  dueDate: task.dueDate?.toISOString().split("T")[0],
  createdAt: task.createdAt?.toISOString(),
  completedAt: task.completedAt?.toISOString(),
});

// Form → DTO
export const taskFormToTaskDto = (
  form: TaskFormTypes
): Omit<TaskDTO, "id" | "createdAt"> => ({
  title: form.title,
  description: form.description,
  category: form.category,
  priority: form.priority,
  status: form.status,
  pomodoro: form.pomodoro,
  dueDate: form.dueDate?.toISOString().split("T")[0],
});

// Массив DTO → Массив Model
export const taskDtosToTasks = (dtos: TaskDTO[]): Task[] =>
  dtos.map(taskDtoToTask);
```

**ui/TaskCard.tsx:**

```tsx
import type { TaskCardProps } from "../model/types";
import { Checkbox } from "@/shared/ui/checkbox";
import React from "react";
import Linkify from "linkify-react";
import { useTaskDrawerStore } from "../model/useTaskDrawerStore";

export const TaskCard = React.memo(({ task, actions }: TaskCardProps) => {
  const openDrawer = useTaskDrawerStore((state) => state.openDrawer);

  return (
    <div
      className="group relative bg-bg-secondary border rounded-xl p-5 
                 hover:border-accent/50 transition-all cursor-pointer"
      onClick={() => openDrawer(task, "view")}
    >
      <div className="flex items-start gap-3">
        <Checkbox onClick={(e) => e.stopPropagation()} />
        <h3 className="font-semibold line-clamp-1">{task.title}</h3>
      </div>

      <div className="text-text-secondary line-clamp-3 ml-8">
        <Linkify>{task.description}</Linkify>
      </div>

      <div className="flex justify-between ml-8 mt-3">
        <div className="text-xs">{task.dueDate?.toLocaleDateString()}</div>
        <div onClick={(e) => e.stopPropagation()}>{actions}</div>
      </div>
    </div>
  );
});
```

**index.ts (Public API):**

```tsx
export { useTaskDrawerStore } from "./model/useTaskDrawerStore";
export { TaskFormSchema, TaskDtoSchema } from "./model/schema";
export type { Task, TaskFormTypes, TaskCardType } from "./model/types";

// UI компоненты НЕ экспортируются
// Они используются напрямую в widgets
```

**Правила entities:**

- Содержит всё, что относится к бизнес-сущности
- Чёткое разделение типов (DTO, Model, Form)
- Mappers для преобразований
- Store для глобального состояния
- UI для отображения (но не экспортируется)

---

### Layer 6: shared (Shared Layer)

**Назначение:** Переиспользуемый код без привязки к бизнес-логике.

**Содержит:**

- UI-kit компоненты
- Утилиты и хелперы
- Константы (маршруты)
- Generic решения

**Структура:**

```
shared/
├── ui/                       # UI компоненты
│   ├── primitives/           # Radix UI обёртки
│   │   ├── alert-dialog.tsx
│   │   ├── calendar.tsx
│   │   ├── dialog.tsx
│   │   ├── drawer.tsx
│   │   ├── dropdown-menu.tsx
│   │   ├── popover.tsx
│   │   ├── tabs.tsx
│   │   └── index.ts
│   ├── button.tsx
│   ├── input.tsx
│   ├── checkbox.tsx
│   └── ...
├── lib/                      # Утилиты
│   ├── classnames/
│   │   ├── cn.ts
│   │   └── index.ts
│   └── drawerTaskManager/
│       ├── drawerStore.ts
│       ├── types.ts
│       └── index.ts
└── routes/
    ├── routes.ts
    └── index.ts
```

#### UI Components (shadcn/ui)

Проект использует **shadcn/ui** - коллекцию компонентов на базе Radix UI и Tailwind CSS.

**Примитивы (primitives/):**

**Dialog:**

```tsx
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/shared/ui/primitives";

<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Title</DialogTitle>
    </DialogHeader>
    {/* Content */}
  </DialogContent>
</Dialog>;
```

**Drawer:**

```tsx
import {
  Drawer,
  DrawerContent,
  DrawerHeader,
  DrawerTitle,
} from "@/shared/ui/primitives";

<Drawer open={open} onOpenChange={setOpen}>
  <DrawerContent>
    <DrawerHeader>
      <DrawerTitle>Title</DrawerTitle>
    </DrawerHeader>
    {/* Content */}
  </DrawerContent>
</Drawer>;
```

**AlertDialog (Confirmation):**

```tsx
import {
  AlertDialog,
  AlertDialogContent,
  AlertDialogAction,
  AlertDialogCancel,
} from "@/shared/ui/primitives";

<AlertDialog open={open} onOpenChange={setOpen}>
  <AlertDialogContent>
    <AlertDialogTitle>Are you sure?</AlertDialogTitle>
    <AlertDialogDescription>
      This action cannot be undone.
    </AlertDialogDescription>
    <AlertDialogCancel>Cancel</AlertDialogCancel>
    <AlertDialogAction onClick={onConfirm}>Confirm</AlertDialogAction>
  </AlertDialogContent>
</AlertDialog>;
```

**Dropdown Menu:**

```tsx
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
} from "@/shared/ui/primitives";

<DropdownMenu>
  <DropdownMenuTrigger>Open</DropdownMenuTrigger>
  <DropdownMenuContent>
    <DropdownMenuItem>Item 1</DropdownMenuItem>
    <DropdownMenuItem>Item 2</DropdownMenuItem>
  </DropdownMenuContent>
</DropdownMenu>;
```

**Базовые компоненты (ui/):**

**Button:**

```tsx
import { Button } from "@/shared/ui/button";

<Button variant="default" size="md" onClick={handleClick}>
  Click me
</Button>;

// Variants: default, outline, ghost, destructive
// Sizes: sm, md, lg, icon
```

**Input:**

```tsx
import { Input } from "@/shared/ui/input";

<Input
  placeholder="Enter text"
  value={value}
  onChange={(e) => setValue(e.target.value)}
/>;
```

**Checkbox:**

```tsx
import { Checkbox } from "@/shared/ui/checkbox";

<Checkbox checked={checked} onCheckedChange={setChecked} />;
```

**Textarea:**

```tsx
import { Textarea } from "@/shared/ui/textarea";

<Textarea
  placeholder="Enter description"
  value={value}
  onChange={(e) => setValue(e.target.value)}
/>;
```

**FormField:**

```tsx
import { FormField } from "@/shared/ui/formField";

<FormField label="Title" error={errors.title?.message}>
  <Input {...register("title")} />
</FormField>;
```

#### lib/classnames - cn()

Утилита для объединения классов с разрешением конфликтов Tailwind.

```tsx
import { cn } from "@/shared/lib/classnames";

<div
  className={cn(
    "base-class",
    isActive && "active-class",
    className // props
  )}
/>;
```

**Реализация:**

```tsx
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

#### lib/drawerTaskManager - Generic Drawer Store

Generic фабрика для создания Zustand stores для drawer/modal.

**types.ts:**

```tsx
export type drawerMode = "view" | "edit";

export interface DrawerState<T> {
  isOpen: boolean;
  data: T | null;
  mode: drawerMode;

  openDrawer: (data: T, mode: "view" | "edit") => void;
  closeDrawer: () => void;
  setMode: (mode: "view" | "edit") => void;
}
```

**drawerStore.ts:**

```tsx
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import type { DrawerState } from "./types";

export const createDrawerStore = <T,>(name: string = "drawer") => {
  return create<DrawerState<T>>()(
    devtools(
      (set) => ({
        isOpen: false,
        data: null,
        mode: "view",

        openDrawer: (data, mode) => {
          set({ isOpen: true, data, mode });
        },

        closeDrawer: () => {
          set({ isOpen: false, data: null, mode: "view" });
        },

        setMode: (mode) => {
          set({ mode });
        },
      }),
      { name }
    )
  );
};
```

**Использование:**

```tsx
// В entities/task
export const useTaskDrawerStore = createDrawerStore<TaskCardType>("taskDrawer");

// В компонентах
const { isOpen, data, mode, openDrawer, closeDrawer } = useTaskDrawerStore();

// Открыть для просмотра
openDrawer(task, "view");

// Открыть для редактирования
openDrawer(task, "edit");

// Закрыть
closeDrawer();
```

#### routes/ - Константы маршрутов

**routes.ts:**

```tsx
export const ROUTES = {
  dashboard: "/",
  tasks: "tasks",
  habits: "habits",
  pomodoro: "pomodoro",
  communities: "communities",
  statistics: "statistics",
  profile: "profile",
};
```

**Использование:**

```tsx
import { ROUTES } from "@/shared/routes";

// В компонентах
<Link to={ROUTES.tasks}>Tasks</Link>

// В роутере
{ path: ROUTES.tasks, Component: TasksPage }
```

**Правила shared:**

- НЕ знает о бизнес-логике
- Максимально generic решения
- Переиспользуемость в любом проекте
- Нет зависимостей на другие слои

---

## Core Modules

### Entity: Task

**Назначение:** Центральная бизнес-сущность приложения - задача.

**Ответственность:**

- Определение структуры данных задачи
- Валидация данных
- Преобразование между форматами (DTO ↔ Model)
- UI для отображения карточки задачи
- Store для управления состоянием drawer

**Где используется:**

- `pages/tasks` - страница со списком задач
- `widgets/taskList` - список задач
- `widgets/taskDrawer` - drawer для просмотра/редактирования
- `features/task/*` - все операции с задачами

**Как расширять:**

1. **Добавить новое поле:**

```tsx
// entities/task/model/types.ts
export type Task = {
  // ...существующие поля
  tags?: string[]; // Новое поле
};

// entities/task/model/schema.ts
export const TaskFormSchema = z.object({
  // ...существующие поля
  tags: z.array(z.string()).optional(),
});

// entities/task/lib/mappers.ts
export const taskDtoToTask = (dto: TaskDTO): Task => ({
  ...dto,
  // ...существующие преобразования
  tags: dto.tags,
});
```

2. **Добавить новый статус:**

```tsx
// entities/task/model/schema.ts
export const TaskFormSchema = z.object({
  // ...
  status: z.enum([
    "pending",
    "in_progress",
    "completed",
    "cancelled",
    "on_hold", // Новый статус
  ]),
});
```

3. **Добавить новый UI компонент:**

```tsx
// entities/task/ui/TaskBadge.tsx
export const TaskBadge = ({ priority }: { priority: Priority }) => {
  const colors = {
    low: "bg-green-500",
    medium: "bg-yellow-500",
    high: "bg-red-500",
  };

  return <span className={colors[priority]}>{priority}</span>;
};

// Использование в widgets
import { TaskBadge } from "@/entities/task/ui/TaskBadge";
```

### Widget: TaskList

**Назначение:** Отображение списка задач с действиями.

**Ответственность:**

- Композиция TaskCard из entities
- Пробрасывание actions (edit, delete)
- Layout для списка (grid)

**Где используется:**

- `pages/tasks` - основная страница задач

**Как расширять:**

1. **Добавить фильтрацию:**

```tsx
// widgets/taskList/ui/TaskList.tsx
interface TaskListProps {
  tasks: Task[];
  filter?: TaskStatus; // Новый prop
}

export const TaskList = ({ tasks, filter }: TaskListProps) => {
  const filteredTasks = filter
    ? tasks.filter(t => t.status === filter)
    : tasks;

  return (
    <div className="grid gap-4">
      {filteredTasks.map((task) => (
        <TaskCard key={task.id} task={task} actions={...} />
      ))}
    </div>
  );
};
```

2. **Добавить сортировку:**

```tsx
export const TaskList = ({ tasks, sortBy }: TaskListProps) => {
  const sortedTasks = useMemo(() => {
    return [...tasks].sort((a, b) => {
      if (sortBy === "dueDate") {
        return (a.dueDate?.getTime() || 0) - (b.dueDate?.getTime() || 0);
      }
      return 0;
    });
  }, [tasks, sortBy]);

  return <div>{/* ... */}</div>;
};
```

### Widget: TaskDrawer

**Назначение:** Drawer для просмотра и редактирования задачи.

**Ответственность:**

- Отображение детальной информации (режим "view")
- Форма редактирования (режим "edit")
- Управление состоянием через store

**Где используется:**

- `pages/tasks` - открывается при клике на TaskCard

**Как расширять:**

1. **Добавить новый режим:**

```tsx
// shared/lib/drawerTaskManager/types.ts
export type drawerMode = "view" | "edit" | "duplicate"; // Новый режим

// widgets/taskDrawer/ui/TaskDrawer.tsx
export const TaskDrawer = () => {
  const { mode, data } = useTaskDrawerStore();

  return (
    <Drawer>
      <DrawerContent>
        {mode === "view" && <TaskInfo task={data} />}
        {mode === "edit" && <EditTaskForm />}
        {mode === "duplicate" && <DuplicateTaskForm />}
      </DrawerContent>
    </Drawer>
  );
};
```

2. **Добавить действия в header:**

```tsx
export const TaskDrawer = () => {
  return (
    <Drawer>
      <DrawerContent>
        <DrawerHeader className="flex justify-between">
          <DrawerTitle>{data.title}</DrawerTitle>
          <div className="flex gap-2">
            <DeleteTaskButton taskId={data.id} />
            <Button onClick={() => setMode("edit")}>Edit</Button>
          </div>
        </DrawerHeader>
        {/* ... */}
      </DrawerContent>
    </Drawer>
  );
};
```

### Widget: Header

**Назначение:** Шапка приложения с навигацией.

**Ответственность:**

- Навигационное меню
- Брендинг
- Возможно: профиль, настройки

**Где используется:**

- `app/layout/Layout.tsx` - в главном layout

**Как расширять:**

```tsx
// widgets/header/ui/Header.tsx
export const Header = () => {
  return (
    <header className="border-b">
      <nav className="flex items-center gap-4 p-4">
        <Logo />
        <NavLinks />
        <div className="ml-auto flex gap-2">
          <ThemeToggle />
          <ProfileDropdown />
        </div>
      </nav>
    </header>
  );
};
```

### Feature: taskAdd

**Назначение:** Создание новой задачи.

**Ответственность:**

- Кнопка "Add task"
- Модальное окно с формой
- Валидация данных
- Отправка на API

**Где используется:**

- `pages/tasks` - в PageHeader как action

**Как расширять:**

1. **Добавить шаблоны задач:**

```tsx
// features/task/taskAdd/model/templates.ts
export const TASK_TEMPLATES = {
  meeting: {
    title: "Meeting",
    category: "work",
    pomodoro: 2,
  },
  workout: {
    title: "Workout",
    category: "health",
    pomodoro: 3,
  },
};

// features/task/taskAdd/ui/TaskForm.tsx
const applyTemplate = (template: keyof typeof TASK_TEMPLATES) => {
  form.reset(TASK_TEMPLATES[template]);
};
```

2. **Добавить быстрое создание:**

```tsx
// features/task/taskAdd/ui/QuickAddTask.tsx
export const QuickAddTask = () => {
  const [title, setTitle] = useState("");

  const handleSubmit = async () => {
    await createTask({
      title,
      priority: "medium",
      status: "pending",
    });
    setTitle("");
  };

  return (
    <Input
      placeholder="Quick add task..."
      value={title}
      onChange={(e) => setTitle(e.target.value)}
      onKeyDown={(e) => e.key === "Enter" && handleSubmit()}
    />
  );
};
```

### Feature: taskEdit

**Назначение:** Редактирование существующей задачи.

**Ответственность:**

- Кнопка "Edit"
- Открытие drawer в режиме "edit"
- Форма редактирования с предзаполненными данными
- Отправка изменений на API

**Где используется:**

- `widgets/taskList` - кнопка в TaskCard
- `widgets/taskDrawer` - форма редактирования

**Как расширять:**

1. **Добавить историю изменений:**

```tsx
// features/task/taskEdit/model/useTaskHistory.ts
export const useTaskHistory = (taskId: string) => {
  const [history, setHistory] = useState<TaskHistoryItem[]>([]);

  useEffect(() => {
    fetchTaskHistory(taskId).then(setHistory);
  }, [taskId]);

  return history;
};

// features/task/taskEdit/ui/TaskHistoryPanel.tsx
export const TaskHistoryPanel = ({ taskId }) => {
  const history = useTaskHistory(taskId);

  return (
    <div>
      {history.map((item) => (
        <div key={item.id}>
          {item.field} changed from {item.oldValue} to {item.newValue}
          <time>{item.timestamp}</time>
        </div>
      ))}
    </div>
  );
};
```

### Feature: taskDelete

**Назначение:** Удаление задачи.

**Ответственность:**

- Кнопка "Delete"
- Подтверждение удаления
- Отправка запроса на API
- Закрытие drawer после удаления

**Где используется:**

- `widgets/taskList` - кнопка в TaskCard
- `widgets/taskDrawer` - кнопка в header

**Как расширять:**

1. **Добавить soft delete (в архив):**

```tsx
// features/task/taskDelete/ui/ArchiveTaskButton.tsx
export const ArchiveTaskButton = ({ taskId }) => {
  const handleArchive = async () => {
    await updateTask(taskId, { status: "archived" });
  };

  return (
    <Button onClick={handleArchive}>
      <Archive className="w-4 h-4" />
      Archive
    </Button>
  );
};
```

2. **Добавить массовое удаление:**

```tsx
// features/task/taskDelete/ui/BulkDeleteButton.tsx
export const BulkDeleteButton = ({ taskIds }) => {
  const { handleBulkDelete } = useBulkDeleteTask();

  return (
    <Button onClick={() => handleBulkDelete(taskIds)}>
      Delete {taskIds.length} tasks
    </Button>
  );
};
```

---

## Система маршрутизации

### Определение маршрутов

**Шаг 1: Константы в shared**

```tsx
// shared/routes/routes.ts
export const ROUTES = {
  dashboard: "/",
  tasks: "tasks",
  habits: "habits",
  // ...
};
```

**Шаг 2: Конфигурация роутера**

```tsx
// app/routes/config/router.tsx
import { ROUTES } from "@/shared/routes";
import { createBrowserRouter } from "react-router";
import { lazy } from "react";
import { Layout } from "@/app/layout/Layout";

const TasksPage = lazy(() => import("@/pages/tasks"));
const HabitsPage = lazy(() => import("@/pages/habits"));

export const router = createBrowserRouter([
  {
    path: "/",
    Component: Layout,
    children: [
      { index: true, Component: DashboardPage },
      { path: ROUTES.tasks, Component: TasksPage },
      { path: ROUTES.habits, Component: HabitsPage },
    ],
  },
]);
```

**Шаг 3: Провайдер роутера**

```tsx
// app/routes/ui/AppRouter.tsx
import { Suspense } from "react";
import { router } from "@/app/routes";
import { RouterProvider } from "react-router";

export const AppRouter = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <RouterProvider router={router} />
  </Suspense>
);
```

### Добавление новой страницы

**Шаг 1: Создать страницу**

```bash
mkdir -p src/pages/analytics/ui
touch src/pages/analytics/ui/AnalyticsPage.tsx
touch src/pages/analytics/index.ts
```

**AnalyticsPage.tsx:**

```tsx
export const AnalyticsPage = () => {
  return (
    <div>
      <h1>Analytics</h1>
      {/* Content */}
    </div>
  );
};
```

**index.ts:**

```tsx
export { AnalyticsPage as default } from "./ui/AnalyticsPage";
```

**Шаг 2: Добавить константу маршрута**

```tsx
// shared/routes/routes.ts
export const ROUTES = {
  // ...
  analytics: "analytics",
};
```

**Шаг 3: Зарегистрировать в роутере**

```tsx
// app/routes/config/router.tsx
const AnalyticsPage = lazy(() => import("@/pages/analytics"));

export const router = createBrowserRouter([
  {
    path: "/",
    Component: Layout,
    children: [
      // ...
      { path: ROUTES.analytics, Component: AnalyticsPage },
    ],
  },
]);
```

**Шаг 4: Добавить навигацию (опционально)**

```tsx
// widgets/header/ui/Header.tsx
<nav>
  <Link to={ROUTES.tasks}>Tasks</Link>
  <Link to={ROUTES.analytics}>Analytics</Link>
</nav>
```

---

## UI архитектура

### Layout System

**Структура:**

```
┌─────────────────────────────────────┐
│            Header                   │
├─────────────────────────────────────┤
│                                     │
│                                     │
│            Main Content             │
│            (Outlet)                 │
│                                     │
│                                     │
└─────────────────────────────────────┘
```

**Layout.tsx:**

```tsx
export const Layout = () => {
  return (
    <div className="flex h-screen">
      <div className="flex flex-col flex-1 w-full">
        <Header />
        <main className="flex-1 bg-bg-secondary px-2 sm:p-3 md:p-4">
          <Outlet />
        </main>
      </div>
    </div>
  );
};
```

**Особенности:**

- Flexbox для full-height layout
- Адаптивные отступы (mobile-first)
- `<Outlet />` для вложенных маршрутов

### Navigation

**Header с навигацией:**

```tsx
import { Link } from "react-router";
import { ROUTES } from "@/shared/routes";

export const Header = () => {
  return (
    <header className="border-b p-4">
      <nav className="flex gap-4">
        <Link to={ROUTES.dashboard}>Dashboard</Link>
        <Link to={ROUTES.tasks}>Tasks</Link>
        <Link to={ROUTES.habits}>Habits</Link>
      </nav>
    </header>
  );
};
```

### Drawer System

**Архитектура drawer:**

1. **Store (в entities):**

```tsx
export const useTaskDrawerStore = createDrawerStore<TaskCardType>("taskDrawer");
```

2. **Trigger (в features):**

```tsx
// OpenEditTaskDrawerButton
const openDrawer = useTaskDrawerStore((state) => state.openDrawer);

<Button onClick={() => openDrawer(task, "edit")}>Edit</Button>;
```

3. **Widget:**

```tsx
// TaskDrawer
const { isOpen, data, mode, closeDrawer } = useTaskDrawerStore();

<Drawer open={isOpen} onOpenChange={closeDrawer}>
  <DrawerContent>
    {mode === "view" && <TaskInfo task={data} />}
    {mode === "edit" && <EditTaskForm />}
  </DrawerContent>
</Drawer>;
```

**Взаимодействие:**

```
TaskCard (click)
  → openDrawer(task, "view")
    → TaskDrawer отображает TaskInfo

Edit Button (click)
  → openDrawer(task, "edit")
    → TaskDrawer отображает EditTaskForm
```

---
